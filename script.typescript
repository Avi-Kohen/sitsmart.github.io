// SitSmart â€” MediaPipe Pose Landmarker (Web)
// Based on the official MediaPipe PoseLandmarker web demo.
// Goal: Hackathon-ready prototype: Student Mode + Teacher Mode (same PC via BroadcastChannel)

import { PoseLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

/** -----------------------------
 *  DOM
 *  ----------------------------- */
const studentView = document.getElementById("studentView");
const teacherView = document.getElementById("teacherView");

const navStudent = document.getElementById("navStudent");
const navTeacher = document.getElementById("navTeacher");

const webcamButton = document.getElementById("webcamButton");
const video = document.getElementById("webcam");
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");

const scoreValueEl = document.getElementById("scoreValue");
const scoreZoneEl = document.getElementById("scoreZone");
const statusLine = document.getElementById("statusLine");

const lightGreen = document.getElementById("lightGreen");
const lightYellow = document.getElementById("lightYellow");
const lightRed = document.getElementById("lightRed");

const overlayMessage = document.getElementById("overlayMessage");
const overlayText = document.getElementById("overlayText");

const calibrateBtn = document.getElementById("calibrateBtn");
const resetBtn = document.getElementById("resetBtn");
const nudgeCountEl = document.getElementById("nudgeCount");
const stretchTimerEl = document.getElementById("stretchTimer");
const studentIdPill = document.getElementById("studentIdPill");

const classAvgEl = document.getElementById("classAvg");
const classRedEl = document.getElementById("classRed");
const classConnectedEl = document.getElementById("classConnected");
const studentTableEl = document.getElementById("studentTable");
const stretchBtn = document.getElementById("stretchBtn");

/** -----------------------------
 *  Constants / Helpers
 *  ----------------------------- */
const CHANNEL_NAME = "sitsmart-v1";
const bc = new BroadcastChannel(CHANNEL_NAME);

const MODEL_URL = "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";
const WASM_URL = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm";

const ZONE = {
  GREEN: "GREEN",
  YELLOW: "YELLOW",
  RED: "RED",
  WAIT: "WAIT"
};

function clamp(v, a, b) {
  return Math.max(a, Math.min(b, v));
}

function nowMs() {
  return performance.now();
}

function fmtSec(sec) {
  if (!Number.isFinite(sec)) return "â€”";
  const s = Math.max(0, Math.round(sec));
  return `${s}s`;
}

function setActiveNav(mode) {
  navStudent.classList.toggle("active", mode === "student");
  navTeacher.classList.toggle("active", mode === "teacher");
}

function setView(mode) {
  if (mode === "teacher") {
    studentView.classList.add("hidden");
    teacherView.classList.remove("hidden");
    setActiveNav("teacher");
  } else {
    teacherView.classList.add("hidden");
    studentView.classList.remove("hidden");
    setActiveNav("student");
  }
}

function getModeFromHash() {
  const h = (location.hash || "").replace("#", "").toLowerCase();
  return h === "teacher" ? "teacher" : "student";
}

/** -----------------------------
 *  Student identity (for demo)
 *  ----------------------------- */
function getOrCreateStudentId() {
  const key = "sitsmart_student_id";
  const existing = localStorage.getItem(key);
  if (existing) return existing;
  const id = `S-${Math.random().toString(16).slice(2, 6).toUpperCase()}`;
  localStorage.setItem(key, id);
  return id;
}

const STUDENT_ID = getOrCreateStudentId();
studentIdPill.textContent = `Student ID: ${STUDENT_ID}`;

/** -----------------------------
 *  MediaPipe setup
 *  ----------------------------- */
let poseLandmarker = null;
let runningMode = "IMAGE";
let webcamRunning = false;
let lastVideoTime = -1;
const drawingUtils = new DrawingUtils(canvasCtx);

async function createPoseLandmarker() {
  statusLine.textContent = "×˜×•×¢×Ÿ ××•×“×œ ×™×¦×™×‘×”â€¦";
  const vision = await FilesetResolver.forVisionTasks(WASM_URL);

  // Prefer GPU, fallback to CPU if needed.
  try {
    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: MODEL_URL, delegate: "GPU" },
      runningMode,
      numPoses: 1
    });
  } catch (e) {
    console.warn("GPU delegate failed; falling back to CPU.", e);
    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: MODEL_URL, delegate: "CPU" },
      runningMode,
      numPoses: 1
    });
  }
  statusLine.textContent = "××•×›×Ÿ. ×œ×—×¥ â€˜×”×¤×¢×œ ××¦×œ××”â€™.";
}

/** -----------------------------
 *  Posture scoring (simple, demo)
 *  ----------------------------- */
let baseline = loadBaseline();
let calibrating = false;
let calibrationEndsAt = 0;
let calibrationSamples = [];

let scoreSmoothed = null;
let redSince = null;
let nudgeCount = 0;
let stretchEndsAt = 0;

function saveBaseline(b) {
  localStorage.setItem("sitsmart_baseline_v1", JSON.stringify(b));
}

function loadBaseline() {
  try {
    const raw = localStorage.getItem("sitsmart_baseline_v1");
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function resetBaseline() {
  baseline = null;
  localStorage.removeItem("sitsmart_baseline_v1");
  statusLine.textContent = "×›×™×•×œ ××•×¤×¡. ××¤×©×¨ ×œ×‘×¦×¢ ×›×™×•×œ ××—×“×©.";
}

function avgPoint(a, b) {
  return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, z: ((a.z ?? 0) + (b.z ?? 0)) / 2 };
}

function angleFromVerticalUp(dx, dy) {
  const mag = Math.hypot(dx, dy);
  if (mag < 1e-6) return 0;
  const dot = (dx * 0 + dy * -1) / mag; // vertical up is (0, -1)
  const c = clamp(dot, -1, 1);
  return Math.acos(c); // radians
}

function getLandmark(landmarks, idx) {
  const p = landmarks?.[idx];
  if (!p) return null;
  // Some versions use visibility; keep it tolerant.
  if (typeof p.visibility === "number" && p.visibility < 0.2) return null;
  return p;
}

function computeMetrics(landmarks) {
  // Indices based on MediaPipe Pose 33 landmarks.
  const shL = getLandmark(landmarks, 11);
  const shR = getLandmark(landmarks, 12);
  const hipL = getLandmark(landmarks, 23);
  const hipR = getLandmark(landmarks, 24);
  const earL = getLandmark(landmarks, 7);
  const earR = getLandmark(landmarks, 8);
  const nose = getLandmark(landmarks, 0);

  if (!shL || !shR || !hipL || !hipR) return null;

  const shoulderMid = avgPoint(shL, shR);
  const hipMid = avgPoint(hipL, hipR);

  let headRef = null;
  if (earL && earR) headRef = avgPoint(earL, earR);
  else if (nose) headRef = nose;
  else headRef = shoulderMid; // fallback

  const torsoDx = shoulderMid.x - hipMid.x;
  const torsoDy = shoulderMid.y - hipMid.y;
  const neckDx = headRef.x - shoulderMid.x;
  const neckDy = headRef.y - shoulderMid.y;

  const torsoAngle = angleFromVerticalUp(torsoDx, torsoDy);
  const neckAngle = angleFromVerticalUp(neckDx, neckDy);

  const shoulderTilt = Math.abs(shL.y - shR.y);
  const headAbove = (shoulderMid.y - headRef.y); // larger => head higher above shoulders

  return {
    torsoAngle,
    neckAngle,
    shoulderTilt,
    headAbove
  };
}

function defaultBaseline() {
  // Reasonable upright defaults (in radians / normalized distances)
  return {
    torsoAngle: 0.12,
    neckAngle: 0.18,
    shoulderTilt: 0.03,
    headAbove: 0.16
  };
}

function computeScore(metrics) {
  const base = baseline ?? defaultBaseline();

  const devTorso = Math.max(0, metrics.torsoAngle - base.torsoAngle);
  const devNeck = Math.max(0, metrics.neckAngle - base.neckAngle);
  const devTilt = Math.max(0, metrics.shoulderTilt - base.shoulderTilt);
  const devHead = Math.max(0, base.headAbove - metrics.headAbove);

  // Convert radians to degrees for nicer scaling.
  const torsoDeg = (devTorso * 180) / Math.PI;
  const neckDeg = (devNeck * 180) / Math.PI;

  let score = 100;
  score -= torsoDeg * 1.25;
  score -= neckDeg * 1.10;
  score -= devTilt * 320;
  score -= devHead * 420;

  return clamp(score, 0, 100);
}

function zoneFromScore(score) {
  if (!Number.isFinite(score)) return ZONE.WAIT;
  if (score >= 75) return ZONE.GREEN;
  if (score >= 55) return ZONE.YELLOW;
  return ZONE.RED;
}

function setLights(zone) {
  lightGreen.className = "light green";
  lightYellow.className = "light yellow";
  lightRed.className = "light red";
  if (zone === ZONE.GREEN) lightGreen.classList.add("on");
  if (zone === ZONE.YELLOW) lightYellow.classList.add("on");
  if (zone === ZONE.RED) lightRed.classList.add("on");
}

function setOverlay(show, text) {
  if (!show) {
    overlayMessage.classList.add("hidden");
    return;
  }
  overlayText.textContent = text;
  overlayMessage.classList.remove("hidden");
}

function updateStudentUI(score, zone) {
  scoreValueEl.textContent = Number.isFinite(score) ? `${Math.round(score)}` : "â€”";
  if (zone === ZONE.GREEN) scoreZoneEl.textContent = "×™×¨×•×§ â€” ××¦×•×™×Ÿ";
  else if (zone === ZONE.YELLOW) scoreZoneEl.textContent = "×¦×”×•×‘ â€” ××¤×©×¨ ×œ×™×™×©×¨";
  else if (zone === ZONE.RED) scoreZoneEl.textContent = "××“×•× â€” ×œ×ª×§×Ÿ ×¨×’×¢";
  else scoreZoneEl.textContent = "×××ª×™×Ÿ";
  setLights(zone);
  nudgeCountEl.textContent = String(nudgeCount);
}

function broadcastStudent(score, zone) {
  bc.postMessage({
    type: "score",
    studentId: STUDENT_ID,
    t: Date.now(),
    score: Number.isFinite(score) ? Math.round(score) : null,
    zone
  });
}

/** -----------------------------
 *  Calibration
 *  ----------------------------- */
function startCalibration() {
  if (!webcamRunning) {
    statusLine.textContent = "×›×“×™ ×œ×›×™×™×œ â€” ×§×•×“× ×œ×”×¤×¢×™×œ ××¦×œ××”.";
    return;
  }
  calibrating = true;
  calibrationSamples = [];
  calibrationEndsAt = Date.now() + 10_000;
  statusLine.textContent = "×›×™×•×œ ×”×ª×—×™×œ: ×©×‘×• ×–×§×•×£ × ×•×— ×œ××©×š 10 ×©× ×™×•×ªâ€¦";
}

function maybeFinishCalibration() {
  if (!calibrating) return;
  const left = calibrationEndsAt - Date.now();
  if (left > 0) {
    stretchTimerEl.textContent = `×›×™×•×œ: ${fmtSec(left / 1000)}`;
    return;
  }
  calibrating = false;
  stretchTimerEl.textContent = "â€”";
  if (calibrationSamples.length < 10) {
    statusLine.textContent = "×›×™×•×œ ×œ× ×”×¦×œ×™×— (×œ× ××¡×¤×™×§ ×¤×¨×™×™××™×). × ×¡×• ×©×•×‘.";
    return;
  }

  const avg = (key) => calibrationSamples.reduce((s, m) => s + m[key], 0) / calibrationSamples.length;
  baseline = {
    torsoAngle: avg("torsoAngle"),
    neckAngle: avg("neckAngle"),
    shoulderTilt: avg("shoulderTilt"),
    headAbove: avg("headAbove")
  };
  saveBaseline(baseline);
  statusLine.textContent = "×›×™×•×œ × ×©××¨ âœ… ×¢×›×©×™×• ×”× ××’×³×™× ××•×ª×××™× ××œ×™×š.";
}

/** -----------------------------
 *  Stretch timer (from teacher)
 *  ----------------------------- */
function startStretch(durationSec = 60) {
  stretchEndsAt = Date.now() + durationSec * 1000;
  setOverlay(true, "××ª×™×—×” ×§×¦×¨×”: × ×©×™××” ×¢××•×§×”, ×›×ª×¤×™×™× ×œ××—×•×¨ ğŸ™‚");
}

function updateStretchTimer() {
  if (!stretchEndsAt) {
    stretchTimerEl.textContent = "â€”";
    return;
  }
  const leftMs = stretchEndsAt - Date.now();
  if (leftMs <= 0) {
    stretchEndsAt = 0;
    setOverlay(false, "");
    stretchTimerEl.textContent = "â€”";
    return;
  }
  stretchTimerEl.textContent = fmtSec(leftMs / 1000);
}

/** -----------------------------
 *  Webcam
 *  ----------------------------- */
function hasGetUserMedia() {
  return !!navigator.mediaDevices?.getUserMedia;
}

async function enableCam() {
  if (!poseLandmarker) {
    statusLine.textContent = "×××ª×™×Ÿ ×œ×˜×¢×™× ×ª ××•×“×œâ€¦";
    return;
  }
  if (!hasGetUserMedia()) {
    statusLine.textContent = "×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘××¦×œ××”.";
    return;
  }

  webcamRunning = !webcamRunning;
  webcamButton.textContent = webcamRunning ? "×›×‘×” ××¦×œ××”" : "×”×¤×¢×œ ××¦×œ××”";

  if (!webcamRunning) {
    const stream = video.srcObject;
    if (stream) {
      stream.getTracks().forEach((t) => t.stop());
      video.srcObject = null;
    }
    scoreSmoothed = null;
    redSince = null;
    setOverlay(false, "");
    updateStudentUI(null, ZONE.WAIT);
    statusLine.textContent = "××¦×œ××” ×›×‘×•×™×”.";
    return;
  }

  const constraints = { video: { facingMode: "user" } };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream;
  video.addEventListener("loadeddata", predictWebcam);
  statusLine.textContent = "××¦×œ××” ×¤×¢×™×œ×”. ××•××œ×¥ ×œ×‘×¦×¢ ×›×™×•×œ.";
}

async function predictWebcam() {
  // Ensure canvas matches video aspect.
  if (video.videoWidth > 0 && video.videoHeight > 0) {
    canvasElement.width = video.videoWidth;
    canvasElement.height = video.videoHeight;
  }

  if (runningMode === "IMAGE") {
    runningMode = "VIDEO";
    await poseLandmarker.setOptions({ runningMode: "VIDEO" });
  }

  const startTimeMs = nowMs();
  if (lastVideoTime !== video.currentTime) {
    lastVideoTime = video.currentTime;
    poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      const lm = result.landmarks?.[0];
      if (lm) {
        // Draw landmarks lightly (optional; helps judges).
        drawingUtils.drawConnectors(lm, PoseLandmarker.POSE_CONNECTIONS, { lineWidth: 2 });
        drawingUtils.drawLandmarks(lm, { radius: 2 });

        const metrics = computeMetrics(lm);
        if (metrics) {
          if (calibrating) {
            calibrationSamples.push(metrics);
            maybeFinishCalibration();
          }

          const raw = computeScore(metrics);
          scoreSmoothed = scoreSmoothed == null ? raw : scoreSmoothed * 0.85 + raw * 0.15;
          const score = scoreSmoothed;
          const zone = zoneFromScore(score);

          // Nudge logic: only if not in stretch mode.
          const inStretch = stretchEndsAt && stretchEndsAt > Date.now();
          if (!inStretch) {
            if (zone === ZONE.RED) {
              if (redSince == null) redSince = Date.now();
              const redForMs = Date.now() - redSince;
              if (redForMs > 2200) {
                setOverlay(true, "×™×™×©×•×¨ ×¢×“×™×Ÿ: ×›×ª×¤×™×™× ×œ××—×•×¨, ×¡× ×˜×¨ ××¢×˜ ×¤× ×™××”");
              }
              if (redForMs > 4200) {
                // Count a nudge every ~4s of continuous red.
                nudgeCount += 1;
                redSince = Date.now();
              }
            } else {
              redSince = null;
              setOverlay(false, "");
            }
          }

          updateStretchTimer();
          updateStudentUI(score, zone);
          broadcastStudent(score, zone);
        }
      }

      canvasCtx.restore();
    });
  }

  if (webcamRunning) {
    window.requestAnimationFrame(predictWebcam);
  }
}

/** -----------------------------
 *  Teacher Mode (aggregation)
 *  ----------------------------- */
const students = new Map();

function msAgo(t) {
  const d = Date.now() - t;
  if (d < 1000) return "×¢×›×©×™×•";
  if (d < 60_000) return `${Math.round(d / 1000)}×©×³`;
  return `${Math.round(d / 60_000)}×“×³`;
}

function badgeForZone(zone) {
  if (zone === ZONE.GREEN) return { text: "×™×¨×•×§", cls: "badge green" };
  if (zone === ZONE.YELLOW) return { text: "×¦×”×•×‘", cls: "badge yellow" };
  if (zone === ZONE.RED) return { text: "××“×•×", cls: "badge red" };
  return { text: "â€”", cls: "badge gray" };
}

function renderTeacher() {
  // prune stale
  const cutoff = Date.now() - 8000;
  for (const [id, s] of students.entries()) {
    if (s.lastSeen < cutoff) students.delete(id);
  }

  const list = Array.from(students.values());
  const connected = list.length;
  const avg = connected ? Math.round(list.reduce((sum, s) => sum + (s.score ?? 0), 0) / connected) : null;
  const red = list.filter((s) => s.zone === ZONE.RED).length;

  classConnectedEl.textContent = connected ? String(connected) : "0";
  classAvgEl.textContent = avg == null ? "â€”" : String(avg);
  classRedEl.textContent = String(red);

  // rebuild table (simple, fast for small demo)
  let head = studentTableEl.querySelector(".tableHead");
  if (!head) {
    head = document.createElement("div");
    head.className = "tableRow tableHead";
    head.innerHTML = "<div>ID</div><div>×¦×™×•×Ÿ</div><div>××¦×‘</div><div>×œ×¤× ×™</div>";
  }
  studentTableEl.innerHTML = "";
  studentTableEl.appendChild(head);

  for (const s of list.sort((a, b) => (b.score ?? 0) - (a.score ?? 0))) {
    const row = document.createElement("div");
    row.className = "tableRow";
    const b = badgeForZone(s.zone);
    row.innerHTML = `
      <div>${s.id}</div>
      <div>${s.score ?? "â€”"}</div>
      <div><span class="${b.cls}">${b.text}</span></div>
      <div>${msAgo(s.lastSeen)}</div>
    `;
    studentTableEl.appendChild(row);
  }
}

// Receive messages
bc.onmessage = (ev) => {
  const msg = ev.data;
  if (!msg || typeof msg !== "object") return;

  if (msg.type === "score") {
    const id = String(msg.studentId || "?");
    students.set(id, {
      id,
      score: typeof msg.score === "number" ? msg.score : null,
      zone: msg.zone || ZONE.WAIT,
      lastSeen: Date.now()
    });
    if (getModeFromHash() === "teacher") renderTeacher();
  }

  if (msg.type === "stretch") {
    // Student receives stretch
    startStretch(msg.durationSec ?? 60);
  }
};

// Teacher triggers stretch
function broadcastStretch(durationSec = 60) {
  bc.postMessage({ type: "stretch", durationSec });
}

/** -----------------------------
 *  Wire UI events
 *  ----------------------------- */
navStudent.addEventListener("click", () => (location.hash = "student"));
navTeacher.addEventListener("click", () => (location.hash = "teacher"));
window.addEventListener("hashchange", () => {
  const mode = getModeFromHash();
  setView(mode);
  if (mode === "teacher") renderTeacher();
});

webcamButton.addEventListener("click", enableCam);
calibrateBtn.addEventListener("click", startCalibration);
resetBtn.addEventListener("click", resetBaseline);

stretchBtn?.addEventListener("click", () => {
  broadcastStretch(60);
});

// Periodic teacher refresh
setInterval(() => {
  if (getModeFromHash() === "teacher") renderTeacher();
  updateStretchTimer();
}, 700);

/** -----------------------------
 *  Boot
 *  ----------------------------- */
setView(getModeFromHash());
setLights(ZONE.WAIT);
updateStudentUI(null, ZONE.WAIT);
updateStretchTimer();

await createPoseLandmarker();
